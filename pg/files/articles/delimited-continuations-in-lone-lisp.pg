extends /templates/article.pg

include /mixins/code.pg

append head
  title Delimited continuations in lone lisp
  meta(name=author content='Matheus Afonso Martins Moreira')
  meta(name=description content='The lone lisp delimited continuations implementation journey.')
  meta(name=keywords content='freestanding, linux, lisp, lone, continuations, delimited-continuations')

  link(rel=stylesheet href=/css/monokai.prism.css)

block article
  h1 Delimited continuations in lone lisp

  a(href='https://github.com/lone-lang/lone/commit/02f8ff3dc97b8a59be2b4d2e2ac947c1f5c41e64').
    Lone now supports delimited continuations!
  p.
    It took me a long time but it's finally here:
    lone now supports one of the most powerful
    control mechanisms there is.

  +code
    :prismjs(language=lisp)
      (import (lone print lambda control transfer) (math +))

      (print
        (+ 1
          (control
            (+ 98 (transfer 41))
            (lambda (value continuation)
              (continuation 1)))))

      ; prints 100

  p.
    Implementing this feature will pave the way to many
    others, such as exception handling and generators.
    However, before moving on with development, I thought
    it would be worthwhile to write down the story of this
    feature's implementation. I want to write the article
    I wish I had read before I began. If nothing else,
    this will serve as documentation for the future version
    of myself whose brain has deleted all this context.

  h2 Iteration
  p.
    Lone was growing in complexity.
    I already had all these data types,
    all of these #[em collections].
    I was having quite a lot of fun
    implementing these things.
    I was learning so much.
    Hash tables? Powerful stuff.
  p.
    However, there was something
    I was secretly avoiding: #[strong iteration].

  p.
    Well, that's not entirely true.
    I didn't #[em completely] avoid the issue.
    Inspired by Ruby, I added some #[code each]
    primitives to the intrinsic modules.

  +code
    :prismjs(language=lisp)
      (import (lone lambda print) (vector each))

      (each [10 20 30]
        (lambda (value)
          (print value)))

  p.
    The way the #[code each] function works internally
    is it iterates over the contents of the vector
    and calls the provided function with each element
    as its sole argument.

  +code
    :prismjs(language=c)
      LONE_LISP_PRIMITIVE(vector_each)
      {
          struct lone_lisp_value vector, f, entry;
          size_t i;

          /* unpack and check arguments... */

          LONE_LISP_VECTOR_FOR_EACH(entry, vector, i) {
              arguments = lone_lisp_list_build(lone, 1, &entry);
              lone_lisp_apply(lone, module, environment, f, arguments);
          }

          return lone_lisp_nil();
      }

  p.
    I cheated a little: I left the #[em actual] iteration
    up to the C compiler. That #[code FOR_EACH] macro
    simply evaluates to a good old #[code for] loop.
    The C code iterates on behalf of lone,
    applying the current element
    to the provided function.

  p.
    So what is the issue? I mean, this works.
    #[em This actually works] just fine!

  p.
    The problem is this made one of lone's limitations
    painfully obvious: lone lacked the ability to control
    the flow of the program. The only thing it knew how to do
    was call functions. That's why I had to implement iteration
    in terms of function calls.

  p.
    I couldn't even begin to imagine how to implement something
    simple like a #[code while] primitive, to say nothing of
    magical stuff like generators. Clearly this was going to
    take a lot more effort than it initially seemed.

  p.
    So I started reading all I could about iteration.
    The ergonomics of it. The design of the interfaces.
    I wanted to do The Right Thing right off the bat.
    I didn't really know what to look for, I just knew
    Ruby's iteration was nice and so lone's should be
    equally nice.

  p.
    The very first result I found while searching was
    #[a(href='https://journal.stuffwithstuff.com/2013/01/13/iteration-inside-and-out/') Bob Nystrom's article].
    I wasn't even surprised. I mean #[em of course]
    he has written about iteration.
    #[a(href='https://journal.stuffwithstuff.com/2013/02/24/iteration-inside-and-out-part-2/') Two articles, even.]
    First he taught me
    #[a(href='https://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/') how to collect garbage],
    now he's going to teach me how to iterate properly.

  p.
    These awesome written articles demonstrate
    exactly why Ruby is nice. Ruby lets programmers
    write nice code that passes values to blocks,
    just like my #[code each] function. Whenever
    that fails to compose, concurrency comes to
    the rescue: Ruby somehow suspends the code
    in the middle of the iteration and yields
    control back to the caller, letting them
    resume whenever they want. This way,
    multiple iterative processes can be
    composed, interleaved or even
    interrupted. #[em Good.]

  p.
    My sense of wonder quickly gave way to horror
    once I realized what was necessary to have such
    goodness. It turned out lone needed the one thing
    it did not have at the time:
    #[em control over the call stack].
    Lone was a
    #[em recursive tree-walking interpreter].
    The call stack, too, was managed by the C compiler.

  p.
    I was going to have to bite the bullet.
    I was going to have to convert lone's
    recursive evaluator into a proper machine
    with registers and a stack.

  h2 Reifying the stack

  p.
    I considered my options. I explored the code bases
    of popular programming language virtual machines.
    They all had bytecode virtual machines.
    How did they implement, say, generators?
    Copy the code, stack and instruction pointer
    into a callable heap allocated object.
    Makes sense, it's just that lone doesn't have
    an instruction pointer. I didn't want to
    transform the lisp code into bytecode.
    Is it really lisp if I get rid if the lists?
    I didn't think so.

  p.
    How do I do this #[em without] transforming the code?
    I decided to ask around in Programming Language Design
    and Implementation communities.
    #[a(href='https://langdev.stackexchange.com/q/3547') I asked this question]
    on the Stack Exchange. I also asked about it on a Discord server.
    I was told about continuation passing style,
    yet another code transformation which I wanted to avoid...
    I #[em really] like those lists!

  p.
    One particular reference kept popping up though:
    Structure and Interpretation of Computer Programs.
    #[abbr(title='Structure and Interpretation of Computer Programs') SICP], for short.
    #[strong THE] book of the Scheme programming language.
    One of the most classic books in the field.
    Computers? Science? More like wizards casting spells,
    computers are merely the runes upon which we inscribe
    our programs. As awesome as that is, the book is not
    an easy read, especially for someone like me who doesn't
    have a background in mathematics or engineering.
    I've tried to read this book a few times by now
    but I never made it through the entire thing.
    So imagine my embarrassment when I realized it
    contained the exact answer to my question all along!
  p.
    #[a(href='https://mitp-content-server.mit.edu/books/content/sectbyfn/books_pres_0/6515/sicp.zip/full-text/book/book-Z-H-34.html') Chapter 5.4],
    one of the very last chapters,
    describes the explicit-control evaluator,
    a register and stack machine which evaluates
    lisp expressions #[em without] converting
    them into something else first.

  h3 The explicit-control evaluator
  p.
    So I read the chapter a few times
    to make sure I had gotten it down
    and once I was somewhat confident
    in my understanding of the machine
    it was describing I went ahead
    and translated the entire thing to C,
    modifying it as I went along.
  p.
    Lone's evaluator did not have many
    special cases. Things like #[code if]
    are traditionally implemented as special
    cases in the evaluator, but since lone
    has FEXPRs I was able to factor them out
    into the intrinsic #[code lone] module.
    In lone, programmers import #[code if]
    as though it was some random function
    instead of a core part of the language.
  p.
    The result was a machine that implements
    what I have come to believe to be the
    #[em true] essence of lisp:
    self-evaluating values,
    and function application.
    A lisp machine, if you will.

  p.
    It starts with an arbitrary lisp expression
    and attempts to reduce it to a single value.
    If the expression is something like a number
    then it cannot be reduced any further.
    The machine just returns it. Easy.

  +code
    :prismjs(language=c)
      expression_evaluation:
          switch (lone_lisp_type_of(machine->expression)) {
          case LONE_LISP_TYPE_NIL:
          case LONE_LISP_TYPE_FALSE:
          case LONE_LISP_TYPE_TRUE:
          case LONE_LISP_TYPE_INTEGER:
              machine->value = machine->expression;
              /* ... */

  p.
    If it's a symbol, the machine looks up
    the value of the symbol in the current
    environment instead. Also easy.

  +code
    :prismjs(language=c)
      case LONE_LISP_TYPE_SYMBOL:
          machine->value = lone_lisp_table_get(lone, machine->environment, machine->expression);
          /* ... */

  p.
    Only when the machine runs into a list
    does it #[em really] start processing.
  p.
    Lists represent #[em function application]
    in the form #[code (f x y z ...)].
    The first thing that needs to happen
    is evaluation of the function itself.
    It's probably a variable pointing to
    the actual function value. It could
    also be a lambda expression.
    Whatever it is, it must be evaluated.
    So the machine loops back into the
    expression evaluation logic, this time
    with #[code f] as the expression.

  +code
    :prismjs(language=c)
      case LONE_LISP_TYPE_LIST:
          /* Save current execution context on the stack... */
          machine->expression = lone_lisp_list_first(machine->expression);
          lone_lisp_machine_push_step(lone, machine, LONE_LISP_MACHINE_STEP_EVALUATED_OPERATOR);
          goto expression_evaluation;

  p.
    Once this is done, it's time to figure out
    what to do with the arguments.
    This depends on the function.

  +code
    :prismjs(language=c)
      if (should_evaluate_operands(machine->applicable, machine->unevaluated)) {
          /* Push some stuff on the stack... */
          machine->step = LONE_LISP_MACHINE_STEP_OPERAND_EVALUATION;
      } else {
          machine->list = machine->unevaluated;
          machine->step = LONE_LISP_MACHINE_STEP_APPLICATION;
      }

  p.
    Normal functions evaluate all arguments.
    In these cases the machine loops back
    and forth, evaluating each argument
    and accumulating the results in a list.
    It's this list that gets passed to the
    function in the end. FEXPRs just skip
    this step, the arguments are passed
    to the function unevaluated.

  +code
    :prismjs(language=c)
      case LONE_LISP_MACHINE_STEP_OPERAND_EVALUATION:
          /* Push some data on the stack... */
          machine->expression = lone_lisp_list_first(machine->unevaluated);
          if (lone_lisp_list_has_rest(machine->unevaluated)) {
              /* Push more data on the stack... */
              lone_lisp_machine_push_step(lone, machine, LONE_LISP_MACHINE_STEP_OPERAND_ACCUMULATION);
          } else {
              /* Evlis tail recursion, no new data pushed on stack */
              lone_lisp_machine_push_step(lone, machine, LONE_LISP_MACHINE_STEP_LAST_OPERAND_ACCUMULATION);
          }
          goto expression_evaluation;
      case LONE_LISP_MACHINE_STEP_OPERAND_ACCUMULATION:
          /* Pop data off the stack... */
          lone_lisp_list_append(lone, &machine->list, &head, machine->value);
          /* Push data back onto the stack... */
          machine->step = LONE_LISP_MACHINE_STEP_OPERAND_EVALUATION;
          /* ... */
      case LONE_LISP_MACHINE_STEP_LAST_OPERAND_ACCUMULATION:
          /* Pop data off the stack... */
          machine->applicable = lone_lisp_machine_pop_value(lone, machine);
          lone_lisp_list_append(lone, &machine->list, &head, machine->value);
          machine->step = LONE_LISP_MACHINE_STEP_APPLICATION;
          /* ... */

  aside
    p.
      What's with all these steps?
      They're just numbers representing
      what the machine's NeXTSTEP is.
      The machine is simply switching on
      the #[code step] variable every cycle.
    p.
      By directly setting this variable
      and associated registers, the machine
      can be explicitly configured to do
      some specific action.
    p.
      Steps can also be pushed on the stack.
      The machine expects to be told what
      the next step is at certain key points.
      This is accomplished by popping a step
      off the stack directly into the step
      register. Through this method, the machine
      can be rigged to do something #[em after]
      it finishes doing whatever it was directly
      configured to do via the above method.

    +code
      :prismjs(language=c)
        enum lone_lisp_machine_step {
            LONE_LISP_MACHINE_STEP_HALT,
            LONE_LISP_MACHINE_STEP_EXPRESSION_EVALUATION,
            LONE_LISP_MACHINE_STEP_EVALUATED_OPERATOR,
            LONE_LISP_MACHINE_STEP_OPERAND_EVALUATION,
            LONE_LISP_MACHINE_STEP_OPERAND_ACCUMULATION,
            LONE_LISP_MACHINE_STEP_LAST_OPERAND_ACCUMULATION,
            LONE_LISP_MACHINE_STEP_APPLICATION,
            /* ... */
        };

  p.
    The next step is to actually apply
    the arguments to the function.
  p.
    When it's a lisp function,
    a new environment is created
    where the variables in the function's
    list of arguments are bound to their
    values, thereby allowing the function
    to reference them. This environment
    also inherits from the function's
    closure, allowing it to reference
    variables that were live when it
    was defined. Pretty standard stuff.
    All that's left to do is evaluate
    the function's body.

  +code
    :prismjs(language=c)
      switch (lone_lisp_heap_value_of(machine->applicable)->type) {
      case LONE_LISP_TYPE_FUNCTION:
          machine->environment = bind_arguments(
              lone,
              machine->environment,
              machine->applicable,
              machine->list
          );
          machine->unevaluated = lone_lisp_heap_value_of(machine->applicable)->as.function.code;
          machine->step = LONE_LISP_MACHINE_STEP_SEQUENCE_EVALUATION;
          /* ... */

  p.
    Primitives are just C functions
    and some metadata. The machine
    just calls them. There is no way
    to automatically assign the lisp
    values to C variables, so the
    arguments list gets passed whole
    to the primitive. It gets to unpack
    the values however it wants.

  p.
    It was at this point that
    I realized an interesting
    situation involving these
    C functions was developing:
    the primitives are going to
    want to call back into lisp.
    For example, #[code if] needs
    the machine to evaluate the
    condition and one of two
    expressions.
  p.
    This doesn't sound so bad at first
    but it in fact spells doom for my
    ultimate goal of controlling the
    flow of the program:

  figure
    blockquote(cite='https://www.wingolog.org/archives/2010/02/26/guile-and-delimited-continuations').
      The second (and deeper) implication is that
      if any intervening code does recurse through
      a foreign function, the resulting partial
      continuation cannot be reinstated.
    figcaption
      cite
        a(href='https://www.wingolog.org/archives/2010/02/26/guile-and-delimited-continuations').
           Andy Wingo, wingolog, #[time(datetime='2010-02-26 20:39') 26 February 2010 8:39 PM]

  p.
    How can I possibly capture and manipulate
    the lisp stack when it's in fact interleaving
    with the C stack? I can't.
  p.
    So after going through #[em all this trouble]
    to convert the recursive evaluator into a machine
    just to expose the lisp stack so that I could
    manipulate it, I end up in this sorry situation
    where lisp calls C which calls lisp again.
  p.
    Clearly, the primitives cannot be allowed
    to recurse back into the machine...
    But how could this work? Many of them
    #[em need] to do this just to work at all!

  p.
    I entertained the idea of just saving the entire
    C stack instead. I quickly gave up on this approach
    but not before I
    #[a(href='https://langdev.stackexchange.com/q/3547') asked a question about it]
    on Stack Exchange which produced a very interesting
    answer. So it #[em was] possible... Probably not
    wise but still. I always find it reassuring when
    I discover I'm not the first person who tried to
    do something that normal people clearly consider
    to be #[em completely insane].

  h3 Integrating the primitives into the machine
  p.
    Enough. No more of this C stack business.
    The primitives #[em cannot be allowed]
    to recurse back into lisp. That's the
    end of it. There's gotta be a way to
    solve this even with this constraint.

  p.
    Inspiration came when I remembered
    #[a(href='https://langdev.stackexchange.com/q/820') this Stack Exchange thread]
    I read while researching generators.
    Turns out generators are just perfectly
    normal functions that got mangled into
    state machines by the language.

  figure
    blockquote(cite='https://langdev.stackexchange.com/a/834')
      +code
        :prismjs(language=c)
          struct fibState {
              a,
              b,
              position
          }

          int fib(fibState state) {
              switch (fibState.postion) {
              case 0:
                  fibState.a, fibState.b = 1,2
                  while (a<100) {
                      fibState.b, fibState.a = fibState.a, fibState.a+fibState.b
                      // switching the context
                      fibState.position = 1;
                      return fibState.a;
              case 1:
                  }

                  fibState.position = 2;
                  return fibState.a-1
              case 2:
                  fibState.position = -1;
              }
          }
    figcaption
      cite
        a(href='https://langdev.stackexchange.com/a/834').
           mousetail,
           Programming Language Design and Implementation Stack Exchange,
           #[time(datetime='2023-05-20 14:06') May 20, 2023 at 14:06]

  p.
    It's got an initial state and it transitions
    to new states as it progresses through its
    code, returning multiple values along the way.
    Could even be made to loop depending on how
    it's set up. Oddly similar to the lisp machine,
    now that I think about it.
    Could these two concepts work together?

  p.
    The answer turned out to be a resounding #[strong yes]!
    I rewrote all of lone's primitives to be state machines
    instead, just like the example in the answer to the
    question. The aforementioned #[code each] primitive,
    for example, which once upon a time was relatively
    simple function, turned into this monstrosity:

  +code
    :prismjs(language=c)
      LONE_LISP_PRIMITIVE(vector_each)
      {
          struct lone_lisp_value arguments, vector, function, entry, expression;
          lone_lisp_integer i;

          switch (step) {
          case 0: /* Initialize and begin iteration */

              /* unpack and check arguments... */

              i = 0;

          iteration:

              entry = lone_lisp_vector_get_value_at(vector, i);

              /* Evaluate (f (v i)) */
              expression = lone_lisp_list_build(lone, 2, &function, &entry);
              lone->machine.step = LONE_LISP_MACHINE_STEP_EXPRESSION_EVALUATION;
              lone->machine.expression = expression;

              /* Push local variables on lisp stack... */

              return 1;

          case 1: /* Advance or finish iteration */

              /* Pop local variables from lisp stack... */

              ++i;

              if (i < lone_lisp_vector_count(vector)) {
                  goto iteration;
              } else {
                  break;
              }
          }

          lone_lisp_machine_push_value(lone, machine, lone_lisp_nil());
          return 0;
      }

  p.
    The machine now passes to the primitive an integer
    that represents the current step in its program.
    The primitive in turn returns to the machine the
    next step in its program. Lisp arguments and return
    values are now passed on the lisp stack.
  p.
    Other than the calling convention, pretty much nothing
    changed for simple primitives that do nothing special.
    The initial and final steps are both zero. They receive
    zero, do their thing and return zero. Done. They don't
    even need to deal with all this step stuff at all.
  p.
    Special primitives, on the other hand, gain the ability
    to interface with the machine. Whenever the primitive
    wants the machine to do something such as evaluate
    an expression, it rigs machine so that it does it
    and returns a non-zero integer. This indicates to
    the machine that it should be resumed later at that
    exact point. The machine goes off and does whatever
    it is that it was asked to do and then it calls
    the primitive again to resume it at the designated
    step. This way, the lisp and C stacks do not ever
    interleave. The C stack is simply not allowed to
    build up. The C function returns instead of calling
    back into lisp.

  p.
    Inversion of control. Don't call the machine,
    the machine will call you. Let it know what you
    need and it will get back to you when it's done.
  p.
    Or maybe it won't! Maybe the machine will ghost
    the primitive and keep it waiting until the end
    of time for a value that will never come.
    When the primitives were simply calling
    evaluator functions, the C compiler guaranteed
    those functions would always return their results
    to them. That's no longer the case.
    #[em The lisp machine is in control now.]

  +code
    :prismjs(language=c)
      case LONE_LISP_TYPE_PRIMITIVE:
          /* Primitives pop the list of arguments from the stack */
          lone_lisp_machine_push_value(lone, machine, machine->list);
          machine->primitive.step = 0;
      resume_primitive:
          machine->primitive.step =
              lone_lisp_heap_value_of(machine->applicable)->as.primitive.function(
                  lone, machine, machine->primitive.step
              );
          if (machine->primitive.step) {
              /* Save primitive context so it can be resumed later... */
              lone_lisp_machine_save_primitive_step(lone, machine);
              lone_lisp_machine_push_value(lone, machine, machine->applicable);
              lone_lisp_machine_push_value(lone, machine, machine->environment);
              lone_lisp_machine_push_step(lone, machine, LONE_LISP_MACHINE_STEP_RESUME_PRIMITIVE);
              /* Go do what the primitive configured the machine to do... */
          } else {
              /* Primitives push the return value onto the stack */
              machine->value = lone_lisp_machine_pop_value(lone, machine);
              /* Go do something else... */
          }
      case LONE_LISP_MACHINE_STEP_RESUME_PRIMITIVE:
          /* Restore primitive context... */
          machine->environment = lone_lisp_machine_pop_value(lone, machine);
          machine->applicable = lone_lisp_machine_pop_value(lone, machine);
          lone_lisp_machine_restore_primitive_step(lone, machine);
          goto resume_primitive;

  p.
    This works and is surprisingly neat.
    Sure, all my primitives turned into
    weird state machines but it's not
    really a big deal. By now I've
    debugged this stuff so much
    I actually started liking it.

  h2 Manipulating the stack
  p.
    What was the point of going through
    all this trouble again? Ah yes.
    I remember now. The stack.
    There it is. Reified.
    Just #[em sitting] there.
    Right in the middle of the structure.
    Literally one pointer away.
    Just waiting to be smashed
    and overflown all night long.
  p.
    So what am I going to do with this thing?
    What #[em can] I do with it?

  p.
    Can I return early from functions?

  +code
    :prismjs(language=lisp)
      (import (lone set print lambda return))

      (set f
        (lambda (x)
          (return 42)
          x))

      (print (f 100)); 42

  p.
    To return, I need to find where
    on the stack the function starts.
    I need to put some kind of marker
    on the stack. #[em A delimiter.]
    It shall be pushed onto the stack
    before the function is called
    and popped off the stack when
    it has finished executing.

  +code
    :prismjs(language=c)
          case LONE_LISP_TYPE_FUNCTION:
              /* ... */
              lone_lisp_machine_push_function_delimiter(lone, machine);
              /* ... */
              /* Machine eventually transitions to AFTER_APPLICATION step... */
          case LONE_LISP_TYPE_PRIMITIVE:
              lone_lisp_machine_push_function_delimiter(lone, machine);
              /* ... */
              if (machine->primitive.step) {
                  /* ... */
              } else {
                  /* Primitives push the return value onto the stack */
                  machine->value = lone_lisp_machine_pop_value(lone, machine);
                  goto after_application;
              }

      case LONE_LISP_MACHINE_STEP_AFTER_APPLICATION:
      after_application:
          lone_lisp_machine_pop_function_delimiter(lone, machine);
          /* ... */

  p.
    Now #[code return] can just unwind
    the stack until it finds this marker.
    To unwind the stack, simply pop off
    frames until you reach the frame you
    were looking for. Once the delimiter
    is on top of the stack, the calling
    convention matches that of primitives.
    The return value can simply be pushed
    onto the stack.

  +code
    :prismjs(language=c)
      LONE_LISP_PRIMITIVE(lone_return)
      {
          struct lone_lisp_machine_stack_frame frame;
          struct lone_lisp_value return_value;

          return_value = /* Unpack argument... */;

          lone_lisp_machine_pop_function_delimiter(lone, machine); // this primitive's own delimiter

          /* Unwind stack to the next function delimiter */
          while (LONE_LISP_MACHINE_STACK_FRAME_TYPE_FUNCTION_DELIMITER !=
                 (frame = lone_lisp_machine_pop(lone, machine)).type);
          lone_lisp_machine_push(lone, machine, frame);

          lone_lisp_machine_push_value(lone, machine, return_value);
          return 0;
      }

  p.
    So #[em this] is the power of the call stack...

  h2 Delimited continuations
  p.
    So completely drunk on the #[em power] of the dark side was I,
    that I decided to go from the humble #[code return] primitive
    to one of the most powerful control mechanisms there is:
    delimited continuations. They say it is the one control
    to rule them all, one control to implement them,
    one control to bring them all, and in the stack
    unwind them.

  p.
    But first I had to wrap my head around plain simple continuations.
    What even #[em are] these things? I knew of their existence because
    of my admittedly shallow knowledge of the Scheme programming language
    but I sure as hell didn't understand them.
    #[a(href='https://en.wikipedia.org/wiki/Call-with-current-continuation') Wikipedia]
    has the following example:

  +code
    :prismjs(language=scheme)
      (define (f return)
        (return 2)
        3)

      (f (lambda (x) x)); 3
      (call-with-current-continuation f); 2

  p.
    It's not immediately apparent what's going on here.
    Let's unpack it step by step.
  p.
    #[code f] takes a function, an applicable value really.
    Nothing special happens when a normal function is passed:
    it gets called, returns, and the program continues on.
  p.
    Passing #[code f] to #[code call-with-current-continuation],
    which by the way is commonly abbreviated as #[code call/cc],
    causes it to be called with the #[em current continuation],
    as the name implies. This current continuation is a super
    special callable value that, when called, somehow causes the
    #[code call/cc] call itself to return the value passed to it.
  p.
    This really flips my bits. I simply have no idea how to use this.
    It sorta looks like my #[code return] primitive from earlier,
    but the function's gotta be threaded through #[code call/cc]?
  p.
    The community once again comes to my rescue.
    A kind soul on Discord pointed me towards
    #[a(href='https://youtu.be/TE48LsgVlIU') a wonderful presentation]
    about delimited continuations. The keynote was given
    by #[a(href='https://lexi-lambda.github.io/') Alexis King],
    the same person who answered one of my Stack Exchange questions
    I mentioned earlier. It's an incredibly insightful presentation
    that's worth watching in its entirety. It really does demystify
    the topic.
  p.
    #[code call/cc] is briefly mentioned
    in the talk and it's explained how
    totally backwards and mind bending it is.
    It's sorta like exceptions but backwards,
    as if the #[code catch] was next to the
    #[code throw]? I think? I'm not even sure.
  p.
    Let's just forget about #[code call/cc].
    #[a(href='https://okmij.org/ftp/continuations/against-callcc.html') Plenty of reasons]
    not to insist on this thing anyway.
    Continuations should be #[em delimited].
    I have learned at least this much.
  p.
    The link between delimited continuations
    and exception handling is another key
    point. It's the mother of all insights,
    the one idea that brings this mystical
    continuation business to the unwashed
    masses: delimited continuations are
    just #[em resumable exceptions].

  p.
    It's as if Python could do this:

  +code
    :prismjs(language=python)
      try:
          print(10 + throw("error"))
      except error, continuation:
          continuation(10)    # Makes throw return 10, prints 20

  p.
    The #[code throw] breaks out of the #[code try]
    block and enters the #[code except] block,
    which is like a function with two arguments:
    the value thrown and the continuation at
    the moment it was thrown.
  p.
    The exception handler code can just ignore
    the continuation and do nothing, which is
    what normally happens when exceptions are
    handled in pretty much every other language.
  p.
    However, the callable continuation value
    allows another possibility: it lets the
    handler code to plug a value back into
    the code being tried, as though the
    #[code throw] primitive had returned it!
    So in this example, after #[code throw]
    breaks out of #[code try] and passes
    control to #[code except], the exception
    handler code #[em goes back into] the
    #[code try] block with a new value,
    allowing it to finish as if it hadn't
    thrown an exception in the first place!
  p.
    OK, that's not entirely accurate:
    calling the continuation doesn't
    actually go back in there.
    By the time the exception handler
    is in control, the #[code try] block
    is no more. The stack has been unwound
    and the code has reached a completely
    different function. What actually happens
    when the continuation is called is it
    #[em brings over] the #[code try] block
    to the call site.

  +code
    :prismjs(language=python)
      try:
        # Unwound
      except error, continuation:
          print(10 + 10)

  p.
    It's as if the #[code throw] primitive
    #[em captured all the pending computations]
    at its call site and reified them into
    a callable value. When called, the
    value gets replaced with those exact
    computations but with the #[code throw]
    primitive replaced with some real value.

  p.
    Let's go back to the lisp machine.
    It's got a stack onto which it pushes
    lots of data as it executes. The stack
    is not made up of just data, however.
    Machine steps are also pushed onto
    the stack. The stack is full of values
    which direct the machine to do things
    in a specific order.
    #[strong The stack is a form of code.]
  p.
    It's this code that forms the "current continuation".
    It's this code that's being captured.

  h3 Capturing the continuation

  p.
    Another key insight in the keynote:
    continuations turn out to be just
    #[code memcpy]ing the stack
    back and forth.

  p.
    The stack is just memory.
    We're going to need a buffer.

  +code
    :prismjs(language=c)
      struct lone_lisp_continuation {
          size_t frame_count;
          struct lone_lisp_machine_stack_frame *frames;
      };

  p.
    We're going to need delimiters too.
    The #[code return] primitive makes
    use of an implicit delimiter managed
    by the lisp machine itself.
    This general #[code control] primitive
    will manage the delimiter all by itself.

  +code
    :prismjs(language=c)
      LONE_LISP_PRIMITIVE(lone_control)
      {
          struct lone_lisp_value arguments, body, handler;

          switch (step) {

          case 0: /* Initialize then evaluate body */

              /* Unpack arguments... */

              lone_lisp_machine_push_value(lone, machine, handler);
              lone_lisp_machine_push_continuation_delimiter(lone);

              machine->step = LONE_LISP_MACHINE_STEP_EXPRESSION_EVALUATION;
              machine->expression = body;

              return 1;

          case 1: /* Body evaluated */

              lone_lisp_machine_pop_continuation_delimiter(lone);
              lone_lisp_machine_pop_value(lone, machine); /* handler */
              lone_lisp_machine_push_value(lone, machine, machine->value); /* return value */
              return 0;

          default:
              linux_exit(-1);
          }
      }

  p.
    This primitive pushes the handler function
    and a continuation delimiter onto the stack.
    Then it evaluates the body of code.
    Once that's done, the primitive discards
    the handler function and the continuation
    delimiter and simply returns the result.
    So by itself it does nothing special.
    It's a glorified #[code begin] primitive.

  p.
    Enter the #[code transfer] primitive.

  +code
    :prismjs(language=c)
      LONE_LISP_PRIMITIVE(lone_transfer)
      {
          struct lone_lisp_machine_stack_frame *delimiter, *frames;
          struct lone_lisp_value arguments, value, continuation, handler;
          size_t frame_count;

          switch (step) {
          case 0: /* Initialize, capture continuation, reset stack and evaluate handler */

              /* Unpack arguments... */

              /* Skips primitive function delimiter and an extraneous step */
              for (delimiter = lone->machine.stack.top - 1 - 2,
                   frame_count = 0;
                   delimiter >= machine->stack.base &&
                   delimiter->type != LONE_LISP_MACHINE_STACK_FRAME_TYPE_CONTINUATION_DELIMITER;
                   --delimiter, ++frame_count);

              /* Allocate memory and copy stack frames up to the continuation delimiter */
              frames = lone_memory_array(lone->system, 0, frame_count, sizeof(*frames));
              lone_memory_move(delimiter + 1, frames, frame_count * sizeof(*frames));

              /* Reify current continuation */
              continuation = lone_lisp_continuation_create(lone, frame_count, frames);

              /* Reset stack back to the continuation delimiter */
              lone->machine.stack.top = delimiter;
              handler = lone_lisp_machine_pop_value(lone, machine);

              /* configure machine to evaluate handler function with value and continuation */
              lone->machine.expression = lone_lisp_list_build(lone, 3, &handler, &value, &continuation);
              lone->machine.step = LONE_LISP_MACHINE_STEP_EXPRESSION_EVALUATION;

              return 1;

          case 1:

              /* Handler has finished evaluation, return the value returned by it */
              lone_lisp_machine_push_value(lone, machine, lone->machine.value);
              return 0;

          default:
              linux_exit(-1);
          }
      }

  p.
    The first thing it does is find the continuation delimiter.
    Then it copies all the stack frames between it and the top
    of the stack into a heap allocated buffer. Then it creates
    a lisp value that just holds this buffer.
    #[em That's the continuation.]
  p.
    Then it unwinds the stack past the continuation delimiter,
    effectively popping off the entire segment of the stack
    that was just copied into the heap. It knows that just
    below the delimiter is the handler function so it pops
    it off the stack. At this point the stack discipline
    matches the initial state of the #[code control]
    primitive. We've really gone back in there!
    From the lisp machine's perspective,
    we're inside #[code control] right now,
    and if we return a value it will be
    as though #[code control] had returned it.
  p.
    The primitive now has the value, the continuation
    and the handler function. There is but one thing
    left to do: evaluate #[code (handler value continuation)].
    The return value of that expression becomes the result
    of the #[code control] primitive.
  p.
    I could stop here and call this an exceptions mechanism.
    If I deleted the continuation capture code, it #[em would]
    be just like the exceptions in every other language!

  h3 Making continuations callable

  p.
    I'm not gonna stop there though.
    I'm so close!
  p.
    My continuation value is just a structure
    that holds an array of stack frames.
    This is a new value type which must be
    properly handled in various parts of
    the system, #[em especially] in the
    garbage collector. Fail to mark and
    sweep these things and memory leaks
    will be the least of your problems.
  p.
    The lisp machine must also be taught
    how to handle these objects.
    In particular, it must be taught
    how to apply a value to it.

  p.
    Like functions, continuations evaluate to themselves.

  +code
    :prismjs(language=c)
      case LONE_LISP_TYPE_CONTINUATION:
          machine->value = machine->expression;
          /* ... */

  p.
    Continuations don't fail the applicable type test.

  +code
    :prismjs(language=c)
      case LONE_LISP_MACHINE_STEP_EVALUATED_OPERATOR:
          /* ... */
          switch (lone_lisp_type_of(machine->applicable)) {
              /* ... */
              case LONE_LISP_TYPE_CONTINUATION:
                  break;
              /* ... */

          if (should_evaluate_operands(machine->applicable, machine->unevaluated))
          /* ... */

  p.
    Continuations always have their arguments evaluated.

  +code
    :prismjs(language=c)
      static bool should_evaluate_operands(/* ... */)
      {
          /* ... */
          switch (lone_lisp_heap_value_of(applicable)->type) {
          /* ... */
          case LONE_LISP_TYPE_CONTINUATION:
              return true;

  p.
    #[strong And finally...]
    When a value is applied to it,
    the machine spills the captured
    stack frames on top of the stack
    and sets the machine registers
    so that the argument flows
    into the computation.

  +code
    :prismjs(language=c)
      case LONE_LISP_MACHINE_STEP_APPLICATION:
          switch (lone_lisp_heap_value_of(machine->applicable)->type) {
              /* ... */
              case LONE_LISP_TYPE_CONTINUATION:
                  if (lone_lisp_list_has_rest(machine->list)) { goto too_many_arguments; }
                  lone_lisp_machine_push_frames(
                      lone,
                      lone_lisp_heap_value_of(machine->applicable)->as.continuation.frame_count,
                      lone_lisp_heap_value_of(machine->applicable)->as.continuation.frames
                  );
                  lone_lisp_machine_restore_step(lone, machine);
                  machine->value = lone_lisp_list_first(machine->list);

  p.
    The continuation is carefully captured
    so as to ensure the machine's next step
    is on top of the stack. The machine simply
    restores that value and off it goes.
    When it's done, the result flows
    naturally into the caller.

  p.
    And just like that, lone has gained
    native first class delimited continuations!
